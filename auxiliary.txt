
template<typename T>
struct Node
{
    T key;
    Node* left;
    Node* right;
};


template<typename T>
struct Node
{
    T key;
    Node* left;
    Node* right;
};

  // struct Node* create(state<double> init_position,double T)
  //  {
  //  	Node* p;
  //   path<double> ini_recur = path_sim(init_position,10);
  //
  //   if (ini_recur[9].time > T){
  //     return NULL;
  //   };
  //   p=(Node*)malloc(sizeof(Node));
  //   p->key=ini_recur;
  //
  //  	p->left=create(ini_recur[10],T);
  //
  //  	p->right=create(ini_recur[10],T);
  //
  //   return p;
  // };
  //
template<typename T>
Node<T>* create()
  {
  	Node<T>* p;
  	T x;
  	printf("Enter data(-1 for no data):");
  	scanf("%d",&x);

  	if(x==-1.)
  		return NULL;

  	p=(Node<T>*)malloc(sizeof(Node<T>));
  	p->key = x;

  	printf("Enter left child of %d:\n",x);
  	p->left= create<T>();

  	printf("Enter right child of %d:\n",x);
  	p->right=create<T>();

  	return p;
}


template<typename T>
void preorder(Node<T>* t)		//address of root node is passed in t
{
	if(t!=NULL)
	{
		preorder(t->left);		//preorder traversal on left subtree
		preorder(t->right);		//preorder traversal om right subtree
	}
}

//
// unsigned int getLeafCount(struct Node* node)
// {
//     if(node == NULL)
//         return 0;
//     if(node->left == NULL && node->right == NULL)
//         return 1;
     else
//         return getLeafCount(node->left)+
//             getLeafCount(node->right);
// }
//
//
// int maxDepth(Node* node)
// {
//     if (node == NULL)
//         return 0;
//     else
//     {
//         /* compute the depth of each subtree */
//         int lDepth = maxDepth(node->left);
//         int rDepth = maxDepth(node->right);
//
//         /* use the larger one */
//         if (lDepth > rDepth)
//             return(lDepth + 1);
//         else return(rDepth + 1);
//     }
// }
//
// void printNodes(Node* root)
// {
//     if (root == nullptr) {
//         return;
//     }
//
//     cout << root->key << " ";
//
//     queue<Node*> q1, q2;
//     q1.push(root->left);
//     q2.push(root->right);
//
//     while (!q1.empty())
//     {
//         int n = q1.size();
//         while (n--)
//         {
//             Node* x = q1.front();
//             q1.pop();
//
//             cout << x->key << " ";
//             if (x->left != NULL) {
//                 q1.push(x->left);
//             }
//
//             if (x->right != NULL) {
//                 q1.push(x->right);
//             }
//             Node* y = q2.front();
//             q2.pop();
//
//             cout << y->key << " ";
//             if (y->right != NULL) {
//                 q2.push(y->right);
//             }
//
//             if (y->left != NULL) {
//                 q2.push(y->left);
//             }
//         }
//     }
// }
//
//
// void SaveNodes(Node* root,ofstream& of)
// {
//     // return if the tree is empty
//     if (root == nullptr) {
//         return;
//     }
//
//     // print the root node
//     of << root->key << " ";
//
//     // create two empty queues and enqueue root's left and
//     // right child, respectively
//     queue<Node*> q1, q2;
//     q1.push(root->left);
//     q2.push(root->right);
//
//     // loop till queue is empty
//     while (!q1.empty())
//     {
//         // calculate the total number of nodes at the current level
//         int n = q1.size();
//
//         // process every node of the current level
//         while (n--)
//         {
//             // dequeue front node from the first queue and print it
//             Node* x = q1.front();
//             q1.pop();
//
//             of << x->key << " ";
//
//             // enqueue left and right child of `x` to the first queue
//             if (x->left) {
//                 q1.push(x->left);
//             }
//
//             if (x->right) {
//                 q1.push(x->right);
//             }
//
//             // dequeue front node from the second queue and print it
//             Node* y = q2.front();
//             q2.pop();
//
//             of << y->key << " ";
//
//             // enqueue right and left child of `y` to the second queue
//             if (y->right) {
//                 q2.push(y->right);
//             }
//
//             if (y->left) {
//                 q2.push(y->left);
//             }
//         }
//     }
// }
//
// void LastLeaves(Node* root){
//   if(root == NULL)
//   {
//     return;
//   }
//   if (root-> left != NULL | root -> right != NULL )
//   {
//       LastLeaves(root->right);
//       LastLeaves(root->left);
//   }
//   else
//   {
//     std::cout << root-> key << std::endl;
//     return;
//   };
// };
// //
// // vector<path<double>> read_vect (const char *Nomfich)
// // {
// //   ifstream fileIn(Nomfich); // fileName is not a good name for a file!
// //
// //   double data;
// //   vector<double> myVec ;
// //   while (fileIn >> data)
// //   {
// //     myVec.push_back(data);
// //   }
// //   int N = myVec.size()/2;
// //   vector<path<double>> mes_petites_particules(N);
// //   for (int i = 0;i<N;i++){
// //     mes_petites_particules[i] = {myVec[2*i],myVec[2*i+1]};
// //   };
// //   return mes_petites_particules;
// // };
//
//
// std::ostream & operator<<(std::ostream &o,const Node& n){
//   o << n.key << std::endl;
//   return o << std::endl;
// };
//
// //
//
// void print2DUtil(Node *root, int space)
// {
//     // Base case
//     if (root == NULL)
//         return;
//
//     // Increase distance between levels
//     space += COUNT;
//
//     // Process right child first
//     print2DUtil(root->right, space);
//
//     // Print current node after space
//     // count
//     cout<<endl;
//     for (int i = COUNT; i < space; i++)
//         cout<<" ";
//     cout<< root->key<< "\n";
//
//     // Process left child
//     print2DUtil(root->left, space);
// }
//
// // Wrapper over print2DUtil()
// void print2D(Node *root)
// {
//     // Pass initial space count as 0
//     print2DUtil(root, 0);
// }
//
//
// struct Trunk
// {
//     Trunk *prev;
//     string str;
//
//     Trunk(Trunk *prev, string str)
//     {
//         this->prev = prev;
//         this->str = str;
//     }
// };
//
// // Helper function to print branches of the binary tree
// void showTrunks(Trunk *p)
// {
//     if (p == nullptr) {
//         return;
//     }
//
//     showTrunks(p->prev);
//     cout << p->str;
// }
//
// // Recursive function to print a binary tree.
// // It uses the inorder traversal.
// void printTree(Node* root, Trunk *prev, bool isLeft)
// {
//     if (root == nullptr) {
//         return;
//     }
//
//     string prev_str = "    ";
//     Trunk *trunk = new Trunk(prev, prev_str);
//
//     printTree(root->right, trunk, true);
//
//     if (!prev) {
//         trunk->str = "———";
//     }
//     else if (isLeft)
//     {
//         trunk->str = ".———";
//         prev_str = "   |";
//     }
//     else {
//         trunk->str = "`———";
//         prev->str = prev_str;
//     }
//
//     showTrunks(trunk);
//     cout << root->key << endl;
//
//     if (prev) {
//         prev->str = prev_str;
//     }
//     trunk->str = "   |";
//
//     printTree(root->left, trunk, false);
// }

template<typename TDistrib1,typename TDistrib2, typename TGen>
struct Galton_Watson{

  Galton_Watson(const TDistrib1 & X,const TDistrib2 & Z, const TGen &gen1 ): X(X),Z_0(Z),gen(gen1),membres(0) {};

  int Taille_population(){
    return membres;
  };

  void start(){
    membres += Z_0(gen);
  };

  void operator()(){
    int somme = 0;
    for (int i = 0;i< membres ;i++){
      somme += X(gen);
    };
    membres += somme;

  };

private:
  TDistrib1 X;
  TDistrib2 Z_0;
  TGen gen;
  int membres;
};

template <typename TDistrib1,typename TDistrib2,typename TGen>
inline Galton_Watson<TDistrib1,TDistrib2,TGen> Galton(const TDistrib1 & X,const TDistrib2 & Z, const TGen &gen ){ return Galton_Watson<TDistrib1,TDistrib2,TGen>(X,Z,gen);};
